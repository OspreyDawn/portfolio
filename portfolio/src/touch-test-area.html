<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/neon-animation/neon-animation.html">
<link rel="import" href="../bower_components/neon-animation/neon-animations.html">

<dom-module id="touch-test-area">
  <template>
    <style>
      .container {
        width: 100%;
        height: 100%;
        position: relative;
      }
    </style>

    <div class="container" id="container">
      <content></content>
    </div>

  </template>

  <script>
    Polymer({

      is: 'touch-test-area',

      behaviors: [Polymer.NeonAnimationRunnerBehavior],

      properties: {
        animationConfig: {
          value: function() {
            return [];
          }
        }
      },

      listeners: {
        'container.track' : 'handleTrack',
        'neon-animation-finish' : '_onNeonAnimationFinish'
      },

      viewWidth: 0,
      xPos: 0,
      xRelease: 0,
      indexSelector: 0,
      indexLength: 0,

      handleTrack: function(e) {
        switch(e.detail.state) {
          case 'start' :
            this.xPos = e.detail.x;
            break;
          case 'track' :
            e.currentTarget.style.left = (e.detail.x - this.xPos) + 'px';
            break;
          case 'end' :
            this.xRelease = e.detail.x - this.xPos;
            this.snapElement(e.currentTarget);
            this.xPos = 0;
            break;
        }
      },

      keyGen: function(element, init, endPos, dur) {
        this.animationConfig['translate'] = {
            name: 'transform-animation',
            node: element,
            transformFrom: 'translateX(' + init + 'px)',
            transformTo: 'translateX(' + endPos + 'px)',
            timing: {
              duration: dur
            }
        }

        this.xEnd = endPos;
      },

      execAnim: function(element, direction, bool) {
        indexInit = this.indexSelector;
        distance = this.viewWidth;

        switch (direction) {
          case 'next':
            this.indexSelector++;
            break;
          case 'prev':
            this.indexSelector--;
            break;
          default:
            this.indexSelector;
          };

          if (bool) {
            currentPosition = this.xRelease - (distance * indexInit);
            duration = 150;
          } else {
            currentPosition = -1 * (distance * indexInit);
            duration = 500;
          }

          nextPosition = distance * this.indexSelector;

        this.xEnd = -nextPosition

        this.keyGen(element, currentPosition, -nextPosition, duration);

        this.playAnimation('translate');
        this.fire('item-page-changed', {vector: direction, indexSelector: this.indexSelector});
      },

      snapElement: function(element) {
        var direction = null;

        if (this.xRelease < -400 && this.indexSelector < (this.indexLength - 1)) {
          direction = 'next';
        } else if (this.xRelease > 400 && this.indexSelector > 0) {
          direction = 'prev';
        }

        element.style.left = 'auto';

        this.execAnim(element, direction, true);
      },

      _onNeonAnimationFinish: function () {
        this.$$('.container').style.transform = 'translateX(' + this.xEnd + 'px)';
      }
    });
  </script>
</dom-module>
